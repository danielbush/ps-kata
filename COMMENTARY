# Session 1

## 21-Mar-2016

First, let's warm up.  For our acceptance tests, we will use cucumber js and webdriver.io.

We'll focus on creating a simplified walking skeleton that developers can use.
Then we may consider how to deploy it to a more realistic architecture that represents
the problem we're trying to solve (agent-based monitoring).

Commits that start with a failing test will be prefixed with CHALLENGE as in "this is
the immediate problem we need to solve".

------------------------------------------------------------

We can run:

  npm test

now and cucumber will give us back our scenario with some helpful
hints about how to implement the step definitions.

We put the first definition in feature/step_definitions/ .

And we decide to re-word the step from 'idle agent' to just 'agent'.
We can make things more complicated later if we have to.

We need an agent and we need it happily running on a target system (a
system we'll be fetching the ps data from).  How to do this?

Well, our agent will be a node process which will then try to talk to
the main server when it has new information to send.
And our target server could just be our system in a dev
environment running the agent.

Do we package the agent and server into different packages?

eg

- ps-agent
- ps-server

We'll use Docker to mimic a production environment.
The agent and main server will run in their own docker containers.
The server will contact the agent and make requests to it.

With this in mind, we'll create 2 subdirectories which will
act as separate npm packages in our repo:

- ps-agent/
- ps-server/

Perhaps in a real project we would create separate git repos, but for
our purposes we'll keep it all together.

We can then create a test agent docker image using:

    ps-agent/Dockerfile

Building the agent would mean:

- building the code if necessary
- rebuilding the docker image with the latest code
  - builds should be relatively fast after the first build
    since the only change will be the app code in
    subsequent builds

Deploying the agent will simply mean starting up the docker container.

Testing would mean doing similar steps for the main server and then driving
a web browser to talk to the main server which would talk to the agent.
We haven't got there yet, we're just trying to get the agent going.

For our agent, let's use an ubuntu 14.04 container with nvm - since this
might be a likely LTS system we would monitor in real life.

We create some gulp commands to build and start a container in ps-agent/.

  cd ps-agent/
  gulp docker:run # runs docker build
  gulp docker:rm-container # to kill it and delete it

What we're probably going to do next is:

- construct a main server similar to our work with the agent above
- have it call /ping on the agent
  - we need to have it start up and know where to find the agent
- have the agent respond with a 200 OK
- have the main server return the OK for a route
  GET /ping/:container-name
- our browser will get back a blank 200 or json response; not very pretty yet, but
  good enough to test a minimum path through the whole stack for our
  walking skeleton

So, we've added express and put in a minimal /ping for the ps-agent.
We'll include a test in ps-agent to test this action in addition to
our walking skeleton test - in the interests of test first.  This feature
and test are minimal and we will refactor this and move on to the main server.

## 24-Mar-2016 - ps-agent docker finally done

Somewhere in this process, we decided to move the docker build logic
out of ps-agent/ and into the parent, which meant moving the gulpfile
for doing docker builds into ps-agent/../ .

So, after another session, we've got a working ps-agent docker
container that we can build in the parent project to the ps-agent
project.

  gulp docker:run:agent # NO LONGER in ps-agent/ but in parent!

should hopefully build a base docker image with our preferred node
version and then build a ps-agent docker image and run our minimal
ps-agent app

There's a slightly kludgy node-env script defined in the base
container to load the correct node version.  (I'm thinking of
switching to 'n' but for the moment I'll stick with nvm.)

Having a gulp file to build and run docker images and containers seems
to be working nicely.  Having this same gulp file not be part of
project (in this case it is in the parent directory to our ps-agent/
project) seems to be the right thing at the moment; developers don't
need docker to run the server in ps-agent/ or "unit" tests.  Any build
logic specific to ps-agent (eg transpiling etc) will still go in
ps-agent/.

We can hopefully accelerate the build our minimal main server
implementation (re-)using what we've done so far for ps-agent/.

## 27-Mar-2016 / 28-Mar-2016

So, using "design by wishful thinking", the first thing we do is
create a gulp task for starting the main server much like the
ps-agent.

  gulp docker:run:main-server

and this will require

  gulp docker:build:main-server

By specifying what we want to see up front, we have a focus to work
towards.

We now have a single gulp task that starts up our server infrastructure:

  gulp docker:run

This will start a test agent in a container and the main server in
another container.  They start on ports 4000 and 4001 respectively.
We can ping both of them and we wrote a ping test using supertest to
verify this behaviour.

In reality, our agent will run on many different environments we just
put it in a container here to mimic one such situation.  We have more
control over our main-server, we can require that it runs in a single
specific container type such as the one we are using here.

We still haven't completed our walking skeleton.  Recall that it must
exercise the whole infrastructure in the most minimal way possible.

Now is a time to revisit our initial cucumber tests and the use of
webdriver since we can use these to drive the next set of actions we
will be taking to establish the walking skeleton.

We can run:

  npm test

in the root of this project to run the cucumber tests which runs our
incomplete heartbeat feature that we started earlier.

We have to start our world up using the cucumber world pattern.
So we create one in

  features/support/world.js

We decide to do a before features hook in cucumber to start docker because
it is currently quite slow.

[31-Mar-2016]

So, when we run

  npm test

we have docker both building and running in a before features hook in
cucumber.  Then it checks that both apps are running by polling the
ports of our main server and one agent we started.

The deploy code we're building seems complicated enough that we might
consider unit testing it.  Starting 2 docker containers and checking
their services are online before continuing can have a bunch of
surprising edge cases.  eg The deploy code has to handle situations
such as a port being already used.

My feeling is to get the pipeline working and ensure that failures are
logged so the broken deployment can be fixed.

The reality seems to be that our deployment is a separate node
package.  In our case, it is the parent directory of the main server
and ps agent.  (In the real world thess would be in sibling
directories with their own git repositories.)

We would probably want to re-use this deploy package across multiple
projects.  And in that case, we would definitely want it tested.  But,
since this is an exercise and I'm feeling my way with the deployment
process here, I'm tempted to keep the tdd for the actual application
code.  I'm just feeling my way with the integration glue code that
we've written so far.  It's almost exploratory.  I'm still doing
design by wishful thinking eg "imagine we have gulp task that already
does X, it would look like..." and pretty much writing it before it's
implemented.  For the moment I don't want to encumber this process
with tests.

So, where are we going:

Running 'npm test' is hideously slow.
It is potentially rebuliding docker images before running and polling
for them.  Then, if that all seems to work, cucumber kicks in.

This could force us to rethink what we're doing a little bit.
Maybe we need to decouple starting our containers from building them.

What we perhaps want to say is

"build version X of our software"

- checkout code with tag or version X
- build docker image with version X

Then we need routine that says:

"do we have version X of the docker images in our docker repository or daemon"

This is our gate for running our acceptance tests.

Finally, we need an action that says:

"Deploy version X (docker run our X-versioned containers) in our environment"
(maybe deleting any running ones first)

and

"wait for them to be up"

